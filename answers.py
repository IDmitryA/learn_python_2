'''

1. break останавливает выполнение цикла.
   continue запускает цикл с начала.

2. while используется для циклического выполнения инструкций пока выполняется заданное условие.
   for...in... для прохождения по некоторому объекту и выполнению определенных инструкций

3. pass - это 'пустой' заполнитель, который ничего не делает. Применяется где этого требует синтаксис (например:
   for i in range(100):
       pass)

4. list - изменяемый список, tuple - неизменяемый список.

5. LEGB: local, enclosing, global, bild-in.

6. min, max - эти функции сравнивают строки в unicod и возвращают соответственно минимальную или
   максимальную строку.

7. Функции - это тоже объекты.

8. 1) при вызове функции, если функция принимает объекты:
      def func(*args):
          pass
      func(1, 2, 3)

   2) внутри функции:
      def func():
          a = input()
          b = inpur
          ...

9. Pep - инструкция по написанию и оформлению кода.

10. Анонимные функции не имеют названия, могут принимать неограниченное число аргументов но содержат только
    одно выражение (результат которого и возвращают), в основном используются единоразово.
    f = lambda x, y: x+y
    f(2,3) => 5

11. Оператор * используется при написании функций если не езвестно сколько аргументов будет передано функции:
    def func(*args). Также для распаковки списков: l = [1, 2, 3, ...]
                                                   print(*l)

12. global для использования функцией переменных из глобальной области видимости, nonlocal для использования
    функцией переменных из области видимости enclosing.

13. Хеш - это число определенного размера, которое идентифицирует определенное значение (изменяется при
    каждом вызове):
    name = 'Dmitry'
    hash(name) => 5833934009921474803

    Хешируемые базовые типы данных:               Нехешируемые базовые типы данных:
    - int                                         - list
    - float                                       - dict
    - string                                      - set
    - tuple
    - frosenset
    - bool

14. Ключем в словаре может быть только хешируемый объект.

15. Меняем местами ключи и значения в словаре:
    d = {1: 'one', 2: 'two'}
    d1 = {v: k for k, v in d.items()}

    Генерируем и выводим матрицу 5х5:
    matrix = []
    line = []
    for i in range(5):
        line.append(i)
        matrix.append(line)
    for m in matrix:
        print(m)

    Получаем уникальные значения из списка:
    list = [1, 2, 3, 3, 4, 5, 2]
    u_list = set(list)

16. Способы объявления строк:
    - string1 = ''
    - string2 = str()

17. Переворачиваем строку:
    some_string = 'у лип Леша нашел пилу'
    reversed_some_string = some_string[::-1]

18. Возводим каждый элемент списка в квадрат:
    list1 = [1, 2, 3, 4, 5]
    for i in range(len(list1)):
        list1[i] = list1[i]**2
    print(list1)

19. Копируем последовательнотсь с помощью среза:
    list1 = [1, 2, 3, 4, 5]
    list2 = list1[::]
    list1 == list2 => True

    Копируем последовательнотсь без среза:
    list1 = [1, 2, 3, 4, 5]
    list2 = list1.copy()
    list1 == list2 => True

20. Переворачиваем последовательность с помощью среза:
    list1 = [1, 2, 3, 4, 5]
    list2 = list1[::-1]

21. Словарь:
    some_dict = {1: 'one', 2: 'two', 3: 'three'}

    Получаем ключи:
    keys = some_dict.keys()

    Получаем значенич:
    values = some_dict.values()

    Получаем список кортежей (ключ, значение)
    items = some_dict.items()

22. Способы формирования строк:

    - способ с оператором '%':
      student1 = 'My name is %s, I am %d years old.' % ('Dmitry', 35)

    - при помощи метода .format():
      student2 = 'My name is {}, I am {} years old.'.format('Dmitry', 35)

    - при помоши f-строк:
      name = 'Dmitry'
      age = 35
      student3 = f'My name is {name}, I am {age} years old.'

23. 1) x = 200
       y = x
       x is y => True, т.к. здесь проверяется указывают ли переменные на один и тот же объект в памяти:
                       id(y) == id(x)
       x == y => True, т.к. здесь проверяется равенство двух значений

    2) x1 = 200
       y1 = 200  переменной у1 присваивается id уже существующего объекта в памяти
       x1 is y1 => True, т.к. здесь проверяется указывают ли переменные на один и тот же объект в памяти:
                         id(y) == id(x)
       x1 == y1 => True, т.к. здесь проверяется равенство двух значений

    3) x2 = 2000
       y2 = 2000 переменной у1 присваивается id уже существующего объекта в памяти
       x2 is y2 => True, т.к. здесь проверяется указывают ли переменные на один и тот же объект в памяти:
                         id(y) == id(x). Но в терминале вернется False, т.к. в терминале при присвоении
                         переменной значения больше 256 создается новый объект в памяти(даже если объект
                         с таким значением существует)
       x2 == y2 => True, т.к. здесь проверяется равенство двух значений

'''
